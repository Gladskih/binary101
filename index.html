<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Local File Inspector</title>
<style>
  :root {
    color-scheme: light dark;
    --background-page: rgb(20 20 24 / 1);
    --background-card: rgb(32 32 38 / 1);
    --border-card: rgb(255 255 255 / 0.08);
    --border-card-hover: rgb(255 255 255 / 0.16);
    --text-primary: rgb(255 255 255 / 0.92);
    --text-secondary: rgb(255 255 255 / 0.6);
    --accent: rgb(99 102 241 / 1);
    --radius-card: 1rem;
    --radius-chip: 0.5rem;
    --font-stack: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
    --transition-fast: 120ms ease;
  }
  @media (prefers-color-scheme: light) {
    :root {
      --background-page: rgb(246 247 249 / 1);
      --background-card: rgb(255 255 255 / 1);
      --border-card: rgb(0 0 0 / 0.08);
      --border-card-hover: rgb(0 0 0 / 0.16);
      --text-primary: rgb(17 24 39 / 1);
      --text-secondary: rgb(55 65 81 / 1);
      --accent: rgb(79 70 229 / 1);
    }
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    min-height: 100dvh;
    background-color: var(--background-page);
    color: var(--text-primary);
    font-family: var(--font-stack);
    display: flex;
    flex-direction: column;
    -webkit-font-smoothing: antialiased;
    line-height: 1.4;
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  header {
    text-align: center;
    padding: 1rem 1rem 0;
    display: grid;
    gap: 0.5rem;
  }
  header h1 {
    font-size: 1rem;
    font-weight: 600;
    margin: 0;
    color: var(--text-primary);
  }
  header p {
    font-size: 0.8rem;
    margin: 0;
    color: var(--text-secondary);
  }
  /* The drop zone is visually the whole main area. It's also the "button". */
  #dropZone {
    flex: 1;
    width: 100%;
    display: grid;
    place-items: center;
    padding: 2rem 1.5rem;
    border: 2px dashed var(--border-card);
    border-radius: 0;
    background-color: var(--background-card);
    color: var(--text-secondary);
    cursor: pointer;
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast), color var(--transition-fast);
  }
  #dropZone.dragover {
    border-color: var(--accent);
    box-shadow: 0 0 1rem rgb(99 102 241 / 0.4);
    color: var(--text-primary);
  }
  #dropZoneInner {
    display: grid;
    gap: 0.75rem;
    max-width: min(480px,90vw);
    text-align: center;
  }
  .zoneTitle {
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-primary);
  }
  .zoneHint {
    font-size: 0.8rem;
    line-height: 1.3;
    color: var(--text-secondary);
  }
  #statusMessage {
    font-size: 0.8rem;
    line-height: 1.3;
    min-height: 1.2em;
    color: var(--accent);
    word-break: break-word;
  }
  section#resultsSection {
    width: min(680px,90vw);
    margin: 1rem auto 2rem;
    display: grid;
    gap: 1rem;
  }
  #fileInfoCard[hidden] {
    display: none;
  }
  #fileInfoCard {
    border: 1px solid var(--border-card);
    border-radius: var(--radius-card);
    background-color: var(--background-card);
    padding: 1rem 1.25rem 1.25rem;
    line-height: 1.5;
  }
  #fileInfoHeader {
    display: flex;
    flex-wrap: wrap;
    align-items: baseline;
    gap: 0.5rem 0.75rem;
    margin-bottom: 0.75rem;
  }
  #fileOriginalName {
    font-size: 1rem;
    font-weight: 600;
    word-break: break-all;
    color: var(--text-primary);
  }
  #fileMetaRow {
    font-size: 0.8rem;
    color: var(--text-secondary);
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
  }
  .chip {
    display: inline-flex;
    align-items: center;
    border-radius: var(--radius-chip);
    background-color: rgb(0 0 0 / 0.2);
    color: var(--text-primary);
    padding: 0.3rem 0.5rem;
    font-size: 0.7rem;
    line-height: 1.2;
  }
  @media (prefers-color-scheme: light) {
    .chip {
      background-color: rgb(0 0 0 / 0.05);
    }
  }
  dl {
    display: grid;
    grid-template-columns: max-content 1fr;
    row-gap: 0.5rem;
    column-gap: 1rem;
    margin: 0;
    font-size: 0.85rem;
  }
  dt {
    color: var(--text-secondary);
  }
  dd {
    margin: 0;
    word-break: break-all;
    color: var(--text-primary);
  }
  .hashRow {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    gap: 0.5rem;
  }
  .hashValue {
    word-break: break-all;
    font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace;
    font-size: 0.8rem;
    line-height: 1.3;
  }
  .hashButtons {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  .actionButton,
  .copyButton {
    appearance: none;
    border: 1px solid var(--accent);
    background-color: var(--accent);
    color: #fff;
    font-size: 0.7rem;
    font-weight: 500;
    line-height: 1.2;
    border-radius: var(--radius-chip);
    padding: 0.5rem 0.6rem;
    cursor: pointer;
    transition: filter var(--transition-fast), box-shadow var(--transition-fast);
  }
  .actionButton:hover,
  .actionButton:focus-visible,
  .copyButton:hover,
  .copyButton:focus-visible {
    filter: brightness(1.1);
    box-shadow: 0 10px 20px rgb(0 0 0 / 0.4);
    outline: none;
  }
  .copyButton[hidden] {
    display: none;
  }
  footer {
    text-align: center;
    font-size: 0.7rem;
    color: var(--text-secondary);
    user-select: none;
    padding: 0 1rem 1rem;
  }
  footer span {
    white-space: nowrap;
  }
  input[type="file"] {
    display: none;
  }
</style>
</head>
<body>
<main>
  <header>
    <h1>Local File Inspector</h1>
    <p>All analysis runs locally in your browser. Nothing is uploaded.</p>
  </header>
  <!--
    We use <label for="fileInput"> so clicking anywhere triggers the hidden file input.
    We still add tabindex and key handling for keyboard activation (Space/Enter),
    because label is not guaranteed to be keyboard-activatable everywhere in a11y terms.
  -->
  <label id="dropZone" for="fileInput" tabindex="0" aria-describedby="zoneHelp">
    <div id="dropZoneInner">
      <div class="zoneTitle">Drop file / Paste (Ctrl+V) / Click to browse</div>
      <div class="zoneHint" id="zoneHelp">
        The whole area is interactive. Single file only. Directories are not supported.
      </div>
      <div id="statusMessage" aria-live="polite" aria-atomic="true"></div>
    </div>
  </label>
  <input id="fileInput" type="file" />
  <section id="resultsSection">
    <article id="fileInfoCard" hidden aria-live="polite" aria-atomic="true">
      <div id="fileInfoHeader">
        <div id="fileOriginalName"></div>
        <div id="fileMetaRow">
          <span class="chip" id="fileSizeDisplay"></span>
          <span class="chip" id="fileKindDisplay"></span>
        </div>
      </div>
      <dl>
        <dt>Original name</dt>
        <dd id="fileNameDetail"></dd>
        <dt>Size</dt>
        <dd id="fileSizeDetail"></dd>
        <dt>Binary type</dt>
        <dd id="fileBinaryTypeDetail"></dd>
        <dt>SHA-256</dt>
        <dd class="hashRow">
          <span class="hashValue" id="sha256Value"></span>
          <div class="hashButtons">
            <button type="button" class="actionButton" id="sha256ComputeButton">Compute SHA-256</button>
            <button type="button" class="copyButton" id="sha256CopyButton" hidden>Copy</button>
          </div>
        </dd>
        <dt>SHA-512</dt>
        <dd class="hashRow">
          <span class="hashValue" id="sha512Value"></span>
          <div class="hashButtons">
            <button type="button" class="actionButton" id="sha512ComputeButton">Compute SHA-512</button>
            <button type="button" class="copyButton" id="sha512CopyButton" hidden>Copy</button>
          </div>
        </dd>
      </dl>
    </article>
  </section>
</main>
<footer>
  <div>Inspection is client-side only.</div>
  <div><span>No upload.</span> <span>No tracking.</span></div>
</footer>
<script type="module">
"use strict";
const dropZoneElement = document.getElementById("dropZone");
const fileInputElement = document.getElementById("fileInput");
const statusMessageElement = document.getElementById("statusMessage");
const fileInfoCardElement = document.getElementById("fileInfoCard");
const fileOriginalNameElement = document.getElementById("fileOriginalName");
const fileSizeDisplayElement = document.getElementById("fileSizeDisplay");
const fileKindDisplayElement = document.getElementById("fileKindDisplay");
const fileNameDetailElement = document.getElementById("fileNameDetail");
const fileSizeDetailElement = document.getElementById("fileSizeDetail");
const fileBinaryTypeDetailElement = document.getElementById("fileBinaryTypeDetail");
const sha256ValueElement = document.getElementById("sha256Value");
const sha512ValueElement = document.getElementById("sha512Value");
const sha256ComputeButtonElement = document.getElementById("sha256ComputeButton");
const sha512ComputeButtonElement = document.getElementById("sha512ComputeButton");
const sha256CopyButtonElement = document.getElementById("sha256CopyButton");
const sha512CopyButtonElement = document.getElementById("sha512CopyButton");

// currentFile is the active file shown in UI
let currentFile = null;

function setStatusMessage(message) {
  statusMessageElement.textContent = message;
}

function clearStatusMessage() {
  statusMessageElement.textContent = "";
}

function formatBytes(bytes) {
  const kilo = 1024;
  if (bytes < kilo) return bytes + " B";
  const units = ["KB", "MB", "GB", "TB", "PB"];
  let value = bytes;
  let unitIndex = -1;
  do {
    value = value / kilo;
    unitIndex += 1;
  } while (value >= kilo && unitIndex < units.length - 1);
  const roundedValue = value >= 100 ? Math.round(value) : Math.round(value * 10) / 10;
  return roundedValue + " " + units[unitIndex];
}

function detectBinaryType(arrayBuffer) {
  const dataView = new DataView(arrayBuffer);
  const byteCount = dataView.byteLength;
  // ELF magic: 0x7F, 'E', 'L', 'F' at offset 0..3
  const isElf =
    byteCount >= 4 &&
    dataView.getUint8(0) === 0x7f &&
    dataView.getUint8(1) === 0x45 && // 'E'
    dataView.getUint8(2) === 0x4c && // 'L'
    dataView.getUint8(3) === 0x46;   // 'F'
  if (isElf) return "ELF";
  // PE/COFF:
  // DOS header must start with 'MZ' (0x4D,0x5A).
  // At offset 0x3C (60 decimal) is e_lfanew, a little-endian 32-bit pointer to the PE header.
  // PE header must start with 'P','E',0x00,0x00.
  const isMz =
    byteCount >= 2 &&
    dataView.getUint8(0) === 0x4d && // 'M'
    dataView.getUint8(1) === 0x5a;   // 'Z'
  if (isMz && byteCount >= 0x3c + 4) {
    const peHeaderOffset = dataView.getUint32(0x3c, true); // e_lfanew is little-endian 32-bit
    if (peHeaderOffset + 4 <= byteCount) {
      const p0 = dataView.getUint8(peHeaderOffset);
      const p1 = dataView.getUint8(peHeaderOffset + 1);
      const p2 = dataView.getUint8(peHeaderOffset + 2);
      const p3 = dataView.getUint8(peHeaderOffset + 3);
      const isPeSignature =
        p0 === 0x50 && // 'P'
        p1 === 0x45 && // 'E'
        p2 === 0x00 &&
        p3 === 0x00;
      if (isPeSignature) return "PE / COFF";
    }
  }
  return "Not ELF or PE / COFF (or file is too short)";
}

async function showFileInformation(file) {
  currentFile = file;
  // We only need the first ~512 bytes to detect ELF / PE.
  // Reading a small slice is safe and fast even for huge files.
  const headerSlice = file.slice(0, 512);
  try {
    const arrayBuffer = await headerSlice.arrayBuffer();
    const binaryType = detectBinaryType(arrayBuffer);
    const readableSize = formatBytes(file.size);
    // basic data
    fileOriginalNameElement.textContent = file.name || "(no name)";
    fileSizeDisplayElement.textContent = readableSize;
    fileKindDisplayElement.textContent = binaryType;
    fileNameDetailElement.textContent = file.name || "(no name)";
    fileSizeDetailElement.textContent = readableSize + " (" + file.size + " bytes)";
    fileBinaryTypeDetailElement.textContent = binaryType;
    // reset hash display state
    sha256ValueElement.textContent = "";
    sha512ValueElement.textContent = "";
    sha256CopyButtonElement.hidden = true;
    sha512CopyButtonElement.hidden = true;
    sha256ComputeButtonElement.hidden = false;
    sha512ComputeButtonElement.hidden = false;
    sha256ComputeButtonElement.disabled = false;
    sha512ComputeButtonElement.disabled = false;
    sha256ComputeButtonElement.textContent = "Compute SHA-256";
    sha512ComputeButtonElement.textContent = "Compute SHA-512";
    fileInfoCardElement.hidden = false;
    clearStatusMessage();
  } catch (error) {
    // If header read fails, we still try to show basic info
    const readableSize = formatBytes(file.size);
    fileOriginalNameElement.textContent = file.name || "(no name)";
    fileSizeDisplayElement.textContent = readableSize;
    fileKindDisplayElement.textContent = "Unreadable";
    fileNameDetailElement.textContent = file.name || "(no name)";
    fileSizeDetailElement.textContent = readableSize + " (" + file.size + " bytes)";
    fileBinaryTypeDetailElement.textContent = "Could not read file header: " + String(error);
    sha256ValueElement.textContent = "";
    sha512ValueElement.textContent = "";
    sha256CopyButtonElement.hidden = true;
    sha512CopyButtonElement.hidden = true;
    sha256ComputeButtonElement.hidden = false;
    sha512ComputeButtonElement.hidden = false;
    sha256ComputeButtonElement.disabled = false;
    sha512ComputeButtonElement.disabled = false;
    sha256ComputeButtonElement.textContent = "Compute SHA-256";
    sha512ComputeButtonElement.textContent = "Compute SHA-512";
    fileInfoCardElement.hidden = false;
    clearStatusMessage();
  }
}

// When the user pastes arbitrary non-file data (for example plain text),
// we synthesize a File object so the rest of the pipeline still works.
function createFileFromString(content, suggestedType) {
  // suggestedType is a best-effort MIME hint (e.g. "text/plain").
  // File name uses timestamp to avoid collisions.
  const safeType = suggestedType || "application/octet-stream";
  return new File([content], "pasted-" + Date.now(), { type: safeType });
}

function handleIncomingFileList(fileList, sourceDescription) {
  if (!fileList || fileList.length === 0) {
    setStatusMessage(sourceDescription + ": no files or unsupported item (for example, a directory).");
    return;
  }
  if (fileList.length > 1) {
    setStatusMessage(sourceDescription + ": multiple files are not supported yet.");
    return;
  }
  const firstFile = fileList[0];
  showFileInformation(firstFile);
}

// drag & drop: note that dropping a directory usually results in 0 files in dataTransfer.files
["dragenter", "dragover"].forEach(type => {
  dropZoneElement.addEventListener(type, event => {
    event.preventDefault();
    dropZoneElement.classList.add("dragover");
  });
});
["dragleave", "drop"].forEach(type => {
  dropZoneElement.addEventListener(type, event => {
    event.preventDefault();
    if (event.type === "drop") {
      const dataTransfer = event.dataTransfer;
      if (!dataTransfer) {
        setStatusMessage("Drop: could not access data.");
      } else {
        handleIncomingFileList(dataTransfer.files, "Drop");
      }
    }
    dropZoneElement.classList.remove("dragover");
  });
});

// keyboard activation of dropZone -> open file dialog
dropZoneElement.addEventListener("keydown", event => {
  if (event.key === " " || event.key === "Enter") {
    event.preventDefault();
    fileInputElement.click();
  }
});

// file dialog change
fileInputElement.addEventListener("change", event => {
  const target = event.currentTarget;
  if (!(target instanceof HTMLInputElement)) return;
  const { files } = target;
  handleIncomingFileList(files, "File selection");
  // Reset to allow selecting the same file twice in a row
  target.value = "";
});

// paste handling
window.addEventListener("paste", async event => {
  const clipboardData = event.clipboardData;
  if (!clipboardData) {
    setStatusMessage("Paste: clipboard not available.");
    return;
  }
  // First, collect File items if present.
  const fileItems = [];
  for (const item of clipboardData.items) {
    if (item.kind === "file") {
      const fileFromClipboard = item.getAsFile();
      if (fileFromClipboard) fileItems.push(fileFromClipboard);
    }
  }
  if (fileItems.length > 0) {
    handleIncomingFileList(fileItems, "Paste");
    return;
  }
  // If there are no file items, try to interpret any string item as content.
  // We prefer "text/plain" if available, else we just take the first string item.
  const stringItems = [];
  for (const item of clipboardData.items) {
    if (item.kind === "string") {
      stringItems.push(item);
    }
  }
  if (stringItems.length === 0) {
    setStatusMessage("Paste: content detected but cannot extract it as a file.");
    return;
  }
  // getAsString is callback-based, so we wrap it
  const readItemAsString = item =>
    new Promise(resolve => {
      item.getAsString(str => resolve({ str, type: item.type }));
    });
  // take the first string item (usually text/plain is first / preferred in common browsers)
  const firstStringItem = stringItems[0];
  const { str, type } = await readItemAsString(firstStringItem);
  if (typeof str === "string" && str.length > 0) {
    const virtualFile = createFileFromString(str, type || "text/plain");
    handleIncomingFileList([virtualFile], "Paste data");
    return;
  }
  setStatusMessage("Paste: content detected but could not interpret as text or file.");
});

// hashing helpers
function arrayBufferToHex(arrayBuffer) {
  const bytes = new Uint8Array(arrayBuffer);
  let hex = "";
  for (const byte of bytes) {
    hex += byte.toString(16).padStart(2, "0");
  }
  return hex;
}

// Clipboard copy helper. Some browsers require user gesture and secure context (https).
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    return false;
  }
}
// Note: hashing large files means reading them fully into memory via file.arrayBuffer().
// This can crash the tab by exhausting memory for extremely large files,
// and that cannot be reliably caught in JavaScript. We still attempt it because
// the user explicitly requested no artificial size limit.
async function computeHash(algorithm, file, valueElement, computeButtonElement, copyButtonElement) {
  if (!file) {
    valueElement.textContent = "No file selected.";
    return;
  }
  computeButtonElement.disabled = true;
  computeButtonElement.textContent = "Workingâ€¦";
  try {
    const fullBuffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest(algorithm, fullBuffer);
    const hexValue = arrayBufferToHex(hashBuffer);
    valueElement.textContent = hexValue;
    // show copy button now that we have a value
    copyButtonElement.hidden = false;
    computeButtonElement.hidden = true;
  } catch (error) {
    valueElement.textContent = "Hash failed: " + String(error);
    computeButtonElement.disabled = false;
    computeButtonElement.textContent = "Retry";
    // copy button stays hidden since we do not have a valid value
    copyButtonElement.hidden = true;
  }
}

// compute buttons
sha256ComputeButtonElement.addEventListener("click", () => {
  computeHash(
    "SHA-256",
    currentFile,
    sha256ValueElement,
    sha256ComputeButtonElement,
    sha256CopyButtonElement
  );
});
sha512ComputeButtonElement.addEventListener("click", () => {
  computeHash(
    "SHA-512",
    currentFile,
    sha512ValueElement,
    sha512ComputeButtonElement,
    sha512CopyButtonElement
  );
});
// copy buttons
sha256CopyButtonElement.addEventListener("click", async () => {
  const text = sha256ValueElement.textContent || "";
  const ok = await copyToClipboard(text);
  if (!ok) {
    setStatusMessage("Clipboard copy failed for SHA-256.");
  } else {
    setStatusMessage("SHA-256 copied.");
  }
});
sha512CopyButtonElement.addEventListener("click", async () => {
  const text = sha512ValueElement.textContent || "";
  const ok = await copyToClipboard(text);
  if (!ok) {
    setStatusMessage("Clipboard copy failed for SHA-512.");
  } else {
    setStatusMessage("SHA-512 copied.");
  }
});
</script>
</body>
</html>
