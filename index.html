<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Local File Inspector</title>
<style>
  :root {
    color-scheme: light dark;
    --background-page: rgb(20 20 24 / 1);
    --background-card: rgb(32 32 38 / 1);
    --border-card: rgb(255 255 255 / 0.08);
    --border-card-hover: rgb(255 255 255 / 0.16);
    --text-primary: rgb(255 255 255 / 0.92);
    --text-secondary: rgb(255 255 255 / 0.6);
    --accent: rgb(99 102 241 / 1);
    --radius-card: 1rem;
    --radius-chip: 0.5rem;
    --font-stack: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
    --transition-fast: 120ms ease;
  }
  @media (prefers-color-scheme: light) {
    :root {
      --background-page: rgb(246 247 249 / 1);
      --background-card: rgb(255 255 255 / 1);
      --border-card: rgb(0 0 0 / 0.08);
      --border-card-hover: rgb(0 0 0 / 0.16);
      --text-primary: rgb(17 24 39 / 1);
      --text-secondary: rgb(55 65 81 / 1);
      --accent: rgb(79 70 229 / 1);
    }
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    min-height: 100dvh;
    background-color: var(--background-page);
    color: var(--text-primary);
    font-family: var(--font-stack);
    display: flex;
    flex-direction: column;
    -webkit-font-smoothing: antialiased;
    line-height: 1.4;
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  header {
    text-align: center;
    padding: 1rem 1rem 0;
    display: grid;
    gap: 0.5rem;
  }
  header h1 {
    font-size: 1rem;
    font-weight: 600;
    margin: 0;
    color: var(--text-primary);
  }
  header p {
    font-size: 0.8rem;
    margin: 0;
    color: var(--text-secondary);
  }
  /* The drop zone is visually the whole main area. It's also the "button". */
  #dropZone {
    flex: 1;
    width: 100%;
    display: grid;
    place-items: center;
    padding: 2rem 1.5rem;
    border: 2px dashed var(--border-card);
    border-radius: 0;
    background-color: var(--background-card);
    color: var(--text-secondary);
    cursor: pointer;
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast), color var(--transition-fast);
  }
  #dropZone.dragover {
    border-color: var(--accent);
    box-shadow: 0 0 1rem rgb(99 102 241 / 0.4);
    color: var(--text-primary);
  }
  #dropZoneInner {
    display: grid;
    gap: 0.75rem;
    max-width: min(480px,90vw);
    text-align: center;
  }
  .zoneTitle {
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-primary);
  }
  .zoneHint {
    font-size: 0.8rem;
    line-height: 1.3;
    color: var(--text-secondary);
  }
  #statusMessage {
    font-size: 0.8rem;
    line-height: 1.3;
    min-height: 1.2em;
    color: var(--accent);
    word-break: break-word;
  }
  section#resultsSection {
    width: min(680px,90vw);
    margin: 1rem auto 2rem;
    display: grid;
    gap: 1rem;
  }
  #fileInfoCard[hidden] {
    display: none;
  }
  #fileInfoCard {
    border: 1px solid var(--border-card);
    border-radius: var(--radius-card);
    background-color: var(--background-card);
    padding: 1rem 1.25rem 1.25rem;
    line-height: 1.5;
  }
  #fileInfoHeader {
    display: flex;
    flex-wrap: wrap;
    align-items: baseline;
    gap: 0.5rem 0.75rem;
    margin-bottom: 0.75rem;
  }
  #fileOriginalName {
    font-size: 1rem;
    font-weight: 600;
    word-break: break-all;
    color: var(--text-primary);
  }
  #fileMetaRow {
    font-size: 0.8rem;
    color: var(--text-secondary);
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
  }
  .chip {
    display: inline-flex;
    align-items: center;
    border-radius: var(--radius-chip);
    background-color: rgb(0 0 0 / 0.2);
    color: var(--text-primary);
    padding: 0.3rem 0.5rem;
    font-size: 0.7rem;
    line-height: 1.2;
  }
  @media (prefers-color-scheme: light) {
    .chip {
      background-color: rgb(0 0 0 / 0.05);
    }
  }
  dl {
    display: grid;
    grid-template-columns: max-content 1fr;
    row-gap: 0.5rem;
    column-gap: 1rem;
    margin: 0;
    font-size: 0.85rem;
  }
  dt {
    color: var(--text-secondary);
  }
  dd {
    margin: 0;
    word-break: break-all;
    color: var(--text-primary);
  }
  .hashRow {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    gap: 0.5rem;
  }
  .hashValue {
    word-break: break-all;
    font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace;
    font-size: 0.8rem;
    line-height: 1.3;
  }
  .hashButtons {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  .actionButton,
  .copyButton {
    appearance: none;
    border: 1px solid var(--accent);
    background-color: var(--accent);
    color: #fff;
    font-size: 0.7rem;
    font-weight: 500;
    line-height: 1.2;
    border-radius: var(--radius-chip);
    padding: 0.5rem 0.6rem;
    cursor: pointer;
    transition: filter var(--transition-fast), box-shadow var(--transition-fast);
  }
  .actionButton:hover,
  .actionButton:focus-visible,
  .copyButton:hover,
  .copyButton:focus-visible {
    filter: brightness(1.1);
    box-shadow: 0 10px 20px rgb(0 0 0 / 0.4);
    outline: none;
  }
  .copyButton[hidden] {
    display: none;
  }
  footer {
    text-align: center;
    font-size: 0.7rem;
    color: var(--text-secondary);
    user-select: none;
    padding: 0 1rem 1rem;
  }
  footer span {
    white-space: nowrap;
  }
  input[type="file"] {
    display: none;
  }
</style>
</head>
<body>
<main>
  <header>
    <h1>Local File Inspector</h1>
    <p>All analysis runs locally in your browser. Nothing is uploaded.</p>
  </header>
  <!--
    We use <label for="fileInput"> so clicking anywhere triggers the hidden file input.
    We still add tabindex and key handling for keyboard activation (Space/Enter),
    because label is not guaranteed to be keyboard-activatable everywhere in a11y terms.
  -->
  <label id="dropZone" for="fileInput" tabindex="0" aria-describedby="zoneHelp">
    <div id="dropZoneInner">
      <div class="zoneTitle">Drop file / Paste (Ctrl+V) / Click to browse</div>
      <div class="zoneHint" id="zoneHelp">
        The whole area is interactive. Single file only. Directories are not supported.
      </div>
      <div id="statusMessage" aria-live="polite" aria-atomic="true"></div>
    </div>
  </label>
  <input id="fileInput" type="file" />
  <section id="resultsSection">
    <article id="fileInfoCard" hidden aria-live="polite" aria-atomic="true">
      <div id="fileInfoHeader">
        <div id="fileOriginalName"></div>
        <div id="fileMetaRow">
          <span class="chip" id="fileSizeDisplay"></span>
          <span class="chip" id="fileKindDisplay"></span>
        </div>
      </div>
      <dl>
        <dt>Original name</dt>
        <dd id="fileNameDetail"></dd>
        <dt>Size</dt>
        <dd id="fileSizeDetail"></dd>
        <dt>Timestamp (UTC)</dt>
        <dd id="fileTimestampDetail"></dd>
        <dt>Source</dt>
        <dd id="fileSourceDetail"></dd>
        <dt>Binary type</dt>
        <dd id="fileBinaryTypeDetail"></dd>
        <dt>SHA-256</dt>
        <dd class="hashRow">
          <span class="hashValue" id="sha256Value"></span>
          <div class="hashButtons">
            <button type="button" class="actionButton" id="sha256ComputeButton">Compute SHA-256</button>
            <button type="button" class="copyButton" id="sha256CopyButton" hidden>Copy</button>
          </div>
        </dd>
        <dt>SHA-512</dt>
        <dd class="hashRow">
          <span class="hashValue" id="sha512Value"></span>
          <div class="hashButtons">
            <button type="button" class="actionButton" id="sha512ComputeButton">Compute SHA-512</button>
            <button type="button" class="copyButton" id="sha512CopyButton" hidden>Copy</button>
          </div>
        </dd>
      </dl>
    </article>
  </section>
</main>
<footer>
  <div>Inspection is client-side only.</div>
  <div><span>No upload.</span> <span>No tracking.</span></div>
</footer>
<script type="module">
"use strict";

const dropZoneElement = document.getElementById("dropZone");
const fileInputElement = document.getElementById("fileInput");
const statusMessageElement = document.getElementById("statusMessage");

const fileInfoCardElement = document.getElementById("fileInfoCard");
const fileOriginalNameElement = document.getElementById("fileOriginalName");
const fileSizeDisplayElement = document.getElementById("fileSizeDisplay");
const fileKindDisplayElement = document.getElementById("fileKindDisplay");
const fileNameDetailElement = document.getElementById("fileNameDetail");
const fileSizeDetailElement = document.getElementById("fileSizeDetail");
const fileBinaryTypeDetailElement = document.getElementById("fileBinaryTypeDetail");
const fileTimestampDetailElement = document.getElementById("fileTimestampDetail");
const fileSourceDetailElement = document.getElementById("fileSourceDetail");

const sha256ValueElement = document.getElementById("sha256Value");
const sha512ValueElement = document.getElementById("sha512Value");
const sha256ComputeButtonElement = document.getElementById("sha256ComputeButton");
const sha512ComputeButtonElement = document.getElementById("sha512ComputeButton");
const sha256CopyButtonElement = document.getElementById("sha256CopyButton");
const sha512CopyButtonElement = document.getElementById("sha512CopyButton");

// currentFile is the active file shown in UI
let currentFile = null;
let currentSourceDescription = "";
let currentAnalysisTimestampUtc = "";

function setStatusMessage(message) {
  statusMessageElement.textContent = message;
}

function clearStatusMessage() {
  statusMessageElement.textContent = "";
}

// Returns something like "2025-11-02T18:45:12Z"
// We intentionally do not strip ":" here because this is now metadata, not a filename.
function getCurrentTimestampUtc() {
  const now = new Date();
  const iso = now.toISOString(); // "2025-11-02T18:45:12.345Z"
  return iso.replace(/\.\d+Z$/, "Z"); // "2025-11-02T18:45:12Z"
}

function formatBytes(bytes) {
  const kilo = 1024;
  if (bytes < kilo) return bytes + " B";
  const units = ["KB", "MB", "GB", "TB", "PB"];
  let value = bytes;
  let unitIndex = -1;
  do {
    value = value / kilo;
    unitIndex += 1;
  } while (value >= kilo && unitIndex < units.length - 1);
  const roundedValue = value >= 100 ? Math.round(value) : Math.round(value * 10) / 10;
  return roundedValue + " " + units[unitIndex];
}

function readAscii(dataView, offset, length) {
  if (offset + length > dataView.byteLength) return "";
  let text = "";
  for (let i = 0; i < length; i += 1) {
    text += String.fromCharCode(dataView.getUint8(offset + i));
  }
  return text;
}

function detectElf(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 0x14) return null;
  const isElf =
    view.getUint8(0) === 0x7f &&
    view.getUint8(1) === 0x45 &&
    view.getUint8(2) === 0x4c &&
    view.getUint8(3) === 0x46;
  if (!isElf) return null;
  const eiClass = view.getUint8(4); // 1 = 32-bit, 2 = 64-bit
  const eiData = view.getUint8(5);  // 1 = little-endian (LSB), 2 = big-endian (MSB)
  const bitnessDescription =
    eiClass === 1 ? "32-bit" :
    eiClass === 2 ? "64-bit" :
    "unknown-width";
  const endiannessDescription =
    eiData === 1 ? "LSB" :
    eiData === 2 ? "MSB" :
    "unknown-endian";
  const littleEndian = eiData === 1;
  // e_type at 0x10 (16-bit)
  // e_machine at 0x12 (16-bit)
  const eType = view.getUint16(0x10, littleEndian);
  const eMachine = view.getUint16(0x12, littleEndian);
  const fileTypeDescription = (() => {
    // e_type values:
    // 1=relocatable, 2=executable, 3=shared object, 4=core
    if (eType === 1) return "relocatable";
    if (eType === 2) return "executable";
    if (eType === 3) return "shared object";
    if (eType === 4) return "core";
    return "type=0x" + eType.toString(16);
  })();
  const machineDescription = (() => {
    // Common e_machine values:
    // 0x03 = x86, 0x3E = x86-64, 0x28 = ARM, 0xB7 = ARM64, 0x08 = MIPS
    if (eMachine === 0x03) return "x86";
    if (eMachine === 0x3e) return "x86-64";
    if (eMachine === 0x28) return "ARM";
    if (eMachine === 0xb7) return "ARM64";
    if (eMachine === 0x08) return "MIPS";
    return "machine=0x" + eMachine.toString(16);
  })();
  return "ELF " + bitnessDescription + " " + endiannessDescription + " " + fileTypeDescription + ", " + machineDescription;
}

function detectPe(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 0x40) return null;
  const isMz =
    view.getUint8(0) === 0x4d &&
    view.getUint8(1) === 0x5a;
  if (!isMz) return null;
  if (view.byteLength < 0x3c + 4) return "PE / COFF (truncated header)";
  const peHeaderOffset = view.getUint32(0x3c, true); // e_lfanew
  if (peHeaderOffset + 4 > view.byteLength) return "PE / COFF (truncated header)";
  const p0 = view.getUint8(peHeaderOffset + 0);
  const p1 = view.getUint8(peHeaderOffset + 1);
  const p2 = view.getUint8(peHeaderOffset + 2);
  const p3 = view.getUint8(peHeaderOffset + 3);
  const isPeSignature =
    p0 === 0x50 && // 'P'
    p1 === 0x45 && // 'E'
    p2 === 0x00 &&
    p3 === 0x00;
  if (!isPeSignature) return null;
  const fileHeaderOffset = peHeaderOffset + 4;
  const minSizeForFileHeader = fileHeaderOffset + 20;
  if (minSizeForFileHeader > view.byteLength) return "PE / COFF (truncated COFF header)";
  const machine = view.getUint16(fileHeaderOffset + 0, true);
  const sizeOfOptionalHeader = view.getUint16(fileHeaderOffset + 16, true);
  const characteristics = view.getUint16(fileHeaderOffset + 18, true);
  const optionalHeaderOffset = fileHeaderOffset + 20;
  if (optionalHeaderOffset + sizeOfOptionalHeader > view.byteLength) {
    return "PE / COFF (truncated optional header)";
  }
  const optionalMagic = view.getUint16(optionalHeaderOffset + 0, true);
  const peFormatDescription =
    optionalMagic === 0x10b ? "PE32" :
    optionalMagic === 0x20b ? "PE32+" :
    optionalMagic === 0x0107 ? "PE32 (ROM image)" :
    "PE (unknown optional header)";
  let subsystemDescription = "subsystem=unknown";
  if (optionalHeaderOffset + 0x46 <= view.byteLength) {
    const subsystem = view.getUint16(optionalHeaderOffset + 0x44, true);
    if (subsystem === 2) subsystemDescription = "GUI";
    else if (subsystem === 3) subsystemDescription = "console";
    else subsystemDescription = "subsystem=" + subsystem;
  }
  const machineDescription = (() => {
    if (machine === 0x014c) return "x86";
    if (machine === 0x8664) return "x86-64";
    if (machine === 0x01c0) return "ARM";
    if (machine === 0xaa64) return "ARM64";
    return "machine=0x" + machine.toString(16);
  })();
  const isDll = (characteristics & 0x2000) !== 0; // IMAGE_FILE_DLL = 0x2000
  const binaryKind = isDll ? "DLL" : "executable";
  return peFormatDescription + " " + binaryKind + " (" + subsystemDescription + ") for " + machineDescription;
}

function detectMachO(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 4) return null;
  const magicBE = view.getUint32(0, false);
  const magicLE = view.getUint32(0, true);
  // Mach-O and fat binaries use well-known 32-bit magic constants.
  // 0xFEEDFACE / 0xCEFAEDFE etc. These are magic numbers from Mach-O headers.
  const MACHO_32_BE = 0xfeedface;
  const MACHO_32_LE = 0xcefaedfe;
  const MACHO_64_BE = 0xfeedfacf;
  const MACHO_64_LE = 0xcffaedfe;
  const FAT_BE = 0xcafebabe;   // universal / fat binary header (big-endian)
  const FAT_LE = 0xbebafeca;   // byte-swapped variant
  if (magicBE === MACHO_32_BE) return "Mach-O 32-bit big-endian";
  if (magicLE === MACHO_32_LE) return "Mach-O 32-bit little-endian";
  if (magicBE === MACHO_64_BE) return "Mach-O 64-bit big-endian";
  if (magicLE === MACHO_64_LE) return "Mach-O 64-bit little-endian";
  if (magicBE === FAT_BE || magicLE === FAT_LE) return "Mach-O universal binary (Fat)";
  return null;
}

function detectPdf(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 5) return null;
  if (
    view.getUint8(0) === 0x25 && // %
    view.getUint8(1) === 0x50 && // P
    view.getUint8(2) === 0x44 && // D
    view.getUint8(3) === 0x46 && // F
    view.getUint8(4) === 0x2d    // -
  ) {
    const headerText = readAscii(view, 0, Math.min(12, view.byteLength));
    return "PDF document (" + headerText.trim() + ")";
  }
  return null;
}

function detectZip(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 4) return null;
  if (
    view.getUint8(0) === 0x50 && // 'P'
    view.getUint8(1) === 0x4b && // 'K'
    view.getUint8(2) === 0x03 &&
    view.getUint8(3) === 0x04
  ) {
    return "ZIP archive (PK)";
  }
  return null;
}

function detectGzip(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 2) return null;
  if (
    view.getUint8(0) === 0x1f &&
    view.getUint8(1) === 0x8b
  ) {
    return "gzip compressed data";
  }
  return null;
}

function detectPng(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 8) return null;
  if (
    view.getUint8(0) === 0x89 &&
    view.getUint8(1) === 0x50 &&
    view.getUint8(2) === 0x4e &&
    view.getUint8(3) === 0x47 &&
    view.getUint8(4) === 0x0d &&
    view.getUint8(5) === 0x0a &&
    view.getUint8(6) === 0x1a &&
    view.getUint8(7) === 0x0a
  ) {
    return "PNG image";
  }
  return null;
}

function detectJpeg(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 3) return null;
  if (
    view.getUint8(0) === 0xff &&
    view.getUint8(1) === 0xd8 &&
    view.getUint8(2) === 0xff
  ) {
    return "JPEG image";
  }
  return null;
}

function detectGif(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  if (view.byteLength < 6) return null;
  const signature = readAscii(view, 0, 6);
  if (signature === "GIF87a" || signature === "GIF89a") {
    return "GIF image (" + signature + ")";
  }
  return null;
}

function detectBinaryType(arrayBuffer) {
  const detectors = [
    detectElf,
    detectPe,
    detectMachO,
    detectPdf,
    detectZip,
    detectGzip,
    detectPng,
    detectJpeg,
    detectGif
  ];
  for (const detector of detectors) {
    const result = detector(arrayBuffer);
    if (result) return result;
  }
  return "Unknown binary type";
}

async function showFileInformation(file, sourceDescription, analysisTimestampUtc) {
  currentFile = file;
  currentSourceDescription = sourceDescription;
  currentAnalysisTimestampUtc = analysisTimestampUtc;

  const headerSlice = file.slice(0, 512);
  try {
    const arrayBuffer = await headerSlice.arrayBuffer();
    const binaryType = detectBinaryType(arrayBuffer);
    const readableSize = formatBytes(file.size);

    fileOriginalNameElement.textContent = file.name || "";
    fileSizeDisplayElement.textContent = readableSize;
    fileKindDisplayElement.textContent = binaryType;

    fileNameDetailElement.textContent = file.name || "";
    fileSizeDetailElement.textContent = readableSize + " (" + file.size + " bytes)";
    fileTimestampDetailElement.textContent = analysisTimestampUtc;
    fileSourceDetailElement.textContent = sourceDescription;
    fileBinaryTypeDetailElement.textContent = binaryType;

    sha256ValueElement.textContent = "";
    sha512ValueElement.textContent = "";
    sha256CopyButtonElement.hidden = true;
    sha512CopyButtonElement.hidden = true;
    sha256ComputeButtonElement.hidden = false;
    sha512ComputeButtonElement.hidden = false;
    sha256ComputeButtonElement.disabled = false;
    sha512ComputeButtonElement.disabled = false;
    sha256ComputeButtonElement.textContent = "Compute SHA-256";
    sha512ComputeButtonElement.textContent = "Compute SHA-512";

    fileInfoCardElement.hidden = false;
    clearStatusMessage();
  } catch (error) {
    const readableSize = formatBytes(file.size);

    fileOriginalNameElement.textContent = file.name || "";
    fileSizeDisplayElement.textContent = readableSize;
    fileKindDisplayElement.textContent = "Unreadable";

    fileNameDetailElement.textContent = file.name || "";
    fileSizeDetailElement.textContent = readableSize + " (" + file.size + " bytes)";
    fileTimestampDetailElement.textContent = analysisTimestampUtc;
    fileSourceDetailElement.textContent = sourceDescription;
    fileBinaryTypeDetailElement.textContent = "Could not read file header: " + String(error);

    sha256ValueElement.textContent = "";
    sha512ValueElement.textContent = "";
    sha256CopyButtonElement.hidden = true;
    sha512CopyButtonElement.hidden = true;
    sha256ComputeButtonElement.hidden = false;
    sha512ComputeButtonElement.hidden = false;
    sha256ComputeButtonElement.disabled = false;
    sha512ComputeButtonElement.disabled = false;
    sha256ComputeButtonElement.textContent = "Compute SHA-256";
    sha512ComputeButtonElement.textContent = "Compute SHA-512";

    fileInfoCardElement.hidden = false;
    clearStatusMessage();
  }
}

// When the user pastes arbitrary non-file data (for example plain text),
// we synthesize a File object so the rest of the pipeline still works.
function createFileFromString(content, suggestedType) {
  const safeType = suggestedType || "application/octet-stream";
  return new File([content], "", { type: safeType });
}

function handleIncomingFileList(fileList, sourceDescription) {
  if (!fileList || fileList.length === 0) {
    setStatusMessage(sourceDescription + ": no files or unsupported item (for example, a directory).");
    return;
  }
  if (fileList.length > 1) {
    setStatusMessage(sourceDescription + ": multiple files are not supported yet.");
    return;
  }
  const firstFile = fileList[0];
  const timestampUtc = getCurrentTimestampUtc();
  showFileInformation(firstFile, sourceDescription, timestampUtc);
}

// drag & drop: note that dropping a directory usually results in 0 files in dataTransfer.files
["dragenter", "dragover"].forEach(type => {
  dropZoneElement.addEventListener(type, event => {
    event.preventDefault();
    dropZoneElement.classList.add("dragover");
  });
});
["dragleave", "drop"].forEach(type => {
  dropZoneElement.addEventListener(type, event => {
    event.preventDefault();
    if (event.type === "drop") {
      const dataTransfer = event.dataTransfer;
      if (!dataTransfer) {
        setStatusMessage("Drop: could not access data.");
      } else {
        handleIncomingFileList(dataTransfer.files, "Drop");
      }
    }
    dropZoneElement.classList.remove("dragover");
  });
});

// keyboard activation of dropZone -> open file dialog
dropZoneElement.addEventListener("keydown", event => {
  if (event.key === " " || event.key === "Enter") {
    event.preventDefault();
    fileInputElement.click();
  }
});

// file dialog change
fileInputElement.addEventListener("change", event => {
  const target = event.currentTarget;
  if (!(target instanceof HTMLInputElement)) return;
  const { files } = target;
  handleIncomingFileList(files, "File selection");
  target.value = "";
});

// paste handling with strict disambiguation policy
window.addEventListener("paste", async event => {
  const clipboardData = event.clipboardData;
  if (!clipboardData) {
    setStatusMessage("Paste: clipboard not available.");
    return;
  }

  const fileItems = [];
  const stringItems = [];
  for (const item of clipboardData.items) {
    if (item.kind === "file") {
      const f = item.getAsFile();
      if (f) fileItems.push(f);
    } else if (item.kind === "string") {
      stringItems.push(item);
    }
  }

  if (fileItems.length > 0 && stringItems.length > 0) {
    setStatusMessage("Paste: clipboard has multiple data items (file and text); not supported yet.");
    return;
  }

  if (fileItems.length > 0) {
    if (fileItems.length === 1) {
      handleIncomingFileList(fileItems, "Paste (file)");
    } else {
      setStatusMessage("Paste: multiple files are not supported yet.");
    }
    return;
  }

  if (stringItems.length === 0) {
    setStatusMessage("Paste: no usable clipboard data.");
    return;
  }
  if (stringItems.length > 1) {
    setStatusMessage("Paste: multiple clipboard text items are not supported yet.");
    return;
  }

  const stringItem = stringItems[0];
  const textContent = await new Promise(resolve => {
    stringItem.getAsString(str => resolve(str));
  });

  if (typeof textContent !== "string" || textContent.length === 0) {
    setStatusMessage("Paste: clipboard text item is empty.");
    return;
  }

  const virtualFile = createFileFromString(
    textContent,
    stringItem.type || "application/octet-stream"
  );
  handleIncomingFileList([virtualFile], "Paste (clipboard data)");
});

// hashing helpers
function arrayBufferToHex(arrayBuffer) {
  const bytes = new Uint8Array(arrayBuffer);
  let hex = "";
  for (const byte of bytes) {
    hex += byte.toString(16).padStart(2, "0");
  }
  return hex;
}

// Clipboard copy helper. Some browsers require user gesture and secure context (https).
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    return false;
  }
}

// Note: hashing large files means reading them fully into memory via file.arrayBuffer().
// This can crash the tab by exhausting memory for extremely large files,
// and that cannot be reliably caught in JavaScript. We still attempt it because
// the user explicitly requested no artificial size limit.
async function computeHash(algorithm, file, valueElement, computeButtonElement, copyButtonElement) {
  if (!file) {
    valueElement.textContent = "No file selected.";
    return;
  }
  computeButtonElement.disabled = true;
  computeButtonElement.textContent = "Workingâ€¦";
  try {
    const fullBuffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest(algorithm, fullBuffer);
    const hexValue = arrayBufferToHex(hashBuffer);
    valueElement.textContent = hexValue;
    copyButtonElement.hidden = false;
    computeButtonElement.hidden = true;
  } catch (error) {
    valueElement.textContent =
      "Hash failed. The browser could not read the full file into memory (" +
      (error && error.name ? error.name + ": " : "") +
      String(error) +
      "). Very large files may exceed available memory.";
    computeButtonElement.disabled = false;
    computeButtonElement.textContent = "Retry";
    copyButtonElement.hidden = true;
  }
}

sha256ComputeButtonElement.addEventListener("click", () => {
  computeHash(
    "SHA-256",
    currentFile,
    sha256ValueElement,
    sha256ComputeButtonElement,
    sha256CopyButtonElement
  );
});

sha512ComputeButtonElement.addEventListener("click", () => {
  computeHash(
    "SHA-512",
    currentFile,
    sha512ValueElement,
    sha512ComputeButtonElement,
    sha512CopyButtonElement
  );
});

sha256CopyButtonElement.addEventListener("click", async () => {
  const text = sha256ValueElement.textContent || "";
  const ok = await copyToClipboard(text);
  if (!ok) {
    setStatusMessage("Clipboard copy failed for SHA-256.");
  } else {
    setStatusMessage("SHA-256 copied.");
  }
});

sha512CopyButtonElement.addEventListener("click", async () => {
  const text = sha512ValueElement.textContent || "";
  const ok = await copyToClipboard(text);
  if (!ok) {
    setStatusMessage("Clipboard copy failed for SHA-512.");
  } else {
    setStatusMessage("SHA-512 copied.");
  }
});
</script>
</body>
</html>
