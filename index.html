<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Local File Inspector</title>
<style>
  :root {
    color-scheme: light dark;
    --background-page: rgb(20 20 24 / 1);
    --background-card: rgb(32 32 38 / 1);
    --border-card: rgb(255 255 255 / 0.08);
    --border-card-hover: rgb(255 255 255 / 0.16);
    --text-primary: rgb(255 255 255 / 0.92);
    --text-secondary: rgb(255 255 255 / 0.6);
    --accent: rgb(99 102 241 / 1);
    --radius-card: 1rem;
    --radius-chip: 0.5rem;
    --font-stack: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
    --transition-fast: 120ms ease;
  }
  @media (prefers-color-scheme: light) {
    :root {
      --background-page: rgb(246 247 249 / 1);
      --background-card: rgb(255 255 255 / 1);
      --border-card: rgb(0 0 0 / 0.08);
      --border-card-hover: rgb(0 0 0 / 0.16);
      --text-primary: rgb(17 24 39 / 1);
      --text-secondary: rgb(55 65 81 / 1);
      --accent: rgb(79 70 229 / 1);
    }
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; min-height: 100dvh; background-color: var(--background-page); color: var(--text-primary);
    font-family: var(--font-stack); display: flex; flex-direction: column; -webkit-font-smoothing: antialiased; line-height: 1.4;
  }
  main { flex: 1; display: flex; flex-direction: column; }
  header { text-align: center; padding: 1rem 1rem 0; display: grid; gap: 0.5rem; }
  header h1 { font-size: 1rem; font-weight: 600; margin: 0; color: var(--text-primary); }
  header p { font-size: 0.8rem; margin: 0; color: var(--text-secondary); }

  #dropZone {
    flex: 1; width: 100%; display: grid; place-items: center; padding: 2rem 1.5rem;
    border: 2px dashed var(--border-card); border-radius: 0; background-color: var(--background-card);
    color: var(--text-secondary); cursor: pointer;
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast), color var(--transition-fast);
  }
  #dropZone.dragover { border-color: var(--accent); box-shadow: 0 0 1rem rgb(99 102 241 / 0.4); color: var(--text-primary); }
  #dropZoneInner { display: grid; gap: 0.75rem; max-width: min(480px,90vw); text-align: center; }
  .zoneTitle { font-size: 1rem; font-weight: 500; color: var(--text-primary); }
  .zoneHint { font-size: 0.8rem; line-height: 1.3; color: var(--text-secondary); }
  #statusMessage { font-size: 0.8rem; line-height: 1.3; min-height: 1.2em; color: var(--accent); word-break: break-word; }

  section#resultsSection { width: min(680px,90vw); margin: 1rem auto 2rem; display: grid; gap: 1rem; }
  #fileInfoCard[hidden] { display: none; }
  #fileInfoCard {
    border: 1px solid var(--border-card); border-radius: var(--radius-card); background-color: var(--background-card);
    padding: 1rem 1.25rem 1.25rem; line-height: 1.5;
  }
  #fileInfoHeader { display: flex; flex-wrap: wrap; align-items: baseline; gap: 0.5rem 0.75rem; margin-bottom: 0.75rem; }
  #fileOriginalName { font-size: 1rem; font-weight: 600; word-break: break-all; color: var(--text-primary); }
  #fileMetaRow { font-size: 0.8rem; color: var(--text-secondary); display: flex; flex-wrap: wrap; gap: 0.75rem; }
  .chip {
    display: inline-flex; align-items: center; border-radius: var(--radius-chip);
    background-color: rgb(0 0 0 / 0.2); color: var(--text-primary);
    padding: 0.3rem 0.5rem; font-size: 0.7rem; line-height: 1.2;
  }
  @media (prefers-color-scheme: light) { .chip { background-color: rgb(0 0 0 / 0.05); } }
  dl { display: grid; grid-template-columns: max-content 1fr; row-gap: 0.5rem; column-gap: 1rem; margin: 0; font-size: 0.85rem; }
  dt { color: var(--text-secondary); }
  dd { margin: 0; word-break: break-all; color: var(--text-primary); }

  .hashRow { display: flex; flex-wrap: wrap; align-items: flex-start; gap: 0.5rem; }
  .hashValue { word-break: break-all; font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace; font-size: 0.8rem; line-height: 1.3; }
  .hashButtons { display: flex; flex-wrap: wrap; gap: 0.5rem; }
  .actionButton,.copyButton {
    appearance: none; border: 1px solid var(--accent); background-color: var(--accent); color: #fff;
    font-size: 0.7rem; font-weight: 500; line-height: 1.2; border-radius: var(--radius-chip); padding: 0.5rem 0.6rem; cursor: pointer;
    transition: filter var(--transition-fast), box-shadow var(--transition-fast);
  }
  .actionButton:hover,.actionButton:focus-visible,.copyButton:hover,.copyButton:focus-visible {
    filter: brightness(1.1); box-shadow: 0 10px 20px rgb(0 0 0 / 0.4); outline: none;
  }
  .copyButton[hidden] { display: none; }

  /* tiny visual helpers for “known options” rows */
  .optionsRow { display: flex; flex-wrap: wrap; gap: 0.25rem 0.5rem; margin-top: 0.25rem; user-select: none; }
  .opt { font-size: 0.72rem; padding: 0.15rem 0.4rem; border-radius: 0.4rem; border: 1px solid var(--border-card); }
  .opt.sel { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent) inset; }
  .opt.dim { opacity: 0.55; }
  .smallNote { color: var(--text-secondary); font-size: 0.72rem; margin-top: 0.25rem; }
  .mono { font-family: ui-monospace,SFMono-Regular,Consolas,"Liberation Mono",monospace; }
  details.help { margin-top: 1rem; }
</style>
</head>
<body>
<main>
  <header>
    <h1>Local File Inspector</h1>
    <p>All analysis runs locally in your browser. Nothing is uploaded.</p>
  </header>

  <label id="dropZone" for="fileInput" tabindex="0" aria-describedby="zoneHelp">
    <div id="dropZoneInner">
      <div class="zoneTitle">Drop file / Paste (Ctrl+V) / Click to browse</div>
      <div class="zoneHint" id="zoneHelp">The whole area is interactive. Single file only. Directories are not supported.</div>
      <div id="statusMessage" aria-live="polite" aria-atomic="true"></div>
    </div>
  </label>
  <input id="fileInput" type="file" />

  <section id="resultsSection">
    <article id="fileInfoCard" hidden aria-live="polite" aria-atomic="true">
      <div id="fileInfoHeader">
        <div id="fileOriginalName"></div>
        <div id="fileMetaRow">
          <span class="chip" id="fileSizeDisplay"></span>
          <span class="chip" id="fileKindDisplay"></span>
        </div>
      </div>
      <dl>
        <dt>Original name</dt><dd id="fileNameDetail"></dd>
        <dt>Size</dt><dd id="fileSizeDetail"></dd>
        <dt>Timestamp (UTC)</dt><dd id="fileTimestampDetail"></dd>
        <dt>Source</dt><dd id="fileSourceDetail"></dd>
        <dt>Binary type</dt><dd id="fileBinaryTypeDetail"></dd>

        <dt id="peDetailsTerm" hidden>PE/COFF details</dt>
        <dd id="peDetailsValue" hidden></dd>

        <dt>SHA-256</dt>
        <dd class="hashRow">
          <span class="hashValue" id="sha256Value"></span>
          <div class="hashButtons">
            <button type="button" class="actionButton" id="sha256ComputeButton">Compute SHA-256</button>
            <button type="button" class="copyButton" id="sha256CopyButton" hidden>Copy</button>
          </div>
        </dd>
        <dt>SHA-512</dt>
        <dd class="hashRow">
          <span class="hashValue" id="sha512Value"></span>
          <div class="hashButtons">
            <button type="button" class="actionButton" id="sha512ComputeButton">Compute SHA-512</button>
            <button type="button" class="copyButton" id="sha512CopyButton" hidden>Copy</button>
          </div>
        </dd>
      </dl>

      <details class="help">
        <summary>Help / assumptions</summary>
        <div class="smallNote">
          Parsed against the PE/COFF format as implemented by Windows loaders (commonly known as the Microsoft PE/COFF specification).<br>
          Field ranges shown are derived from the field width (e.g., 16-bit → 0..65535) and practical expectations where noted. Section names are conventional, not enforced.
        </div>
      </details>
    </article>
  </section>
</main>
<footer>
  <div>Inspection is client-side only.</div>
  <div><span>No upload.</span> <span>No tracking.</span></div>
</footer>

<script type="module">
"use strict";

const dropZoneElement = document.getElementById("dropZone");
const fileInputElement = document.getElementById("fileInput");
const statusMessageElement = document.getElementById("statusMessage");

const fileInfoCardElement = document.getElementById("fileInfoCard");
const fileOriginalNameElement = document.getElementById("fileOriginalName");
const fileSizeDisplayElement = document.getElementById("fileSizeDisplay");
const fileKindDisplayElement = document.getElementById("fileKindDisplay");
const fileNameDetailElement = document.getElementById("fileNameDetail");
const fileSizeDetailElement = document.getElementById("fileSizeDetail");
const fileBinaryTypeDetailElement = document.getElementById("fileBinaryTypeDetail");
const fileTimestampDetailElement = document.getElementById("fileTimestampDetail");
const fileSourceDetailElement = document.getElementById("fileSourceDetail");

const peDetailsTermElement = document.getElementById("peDetailsTerm");
const peDetailsValueElement = document.getElementById("peDetailsValue");

const sha256ValueElement = document.getElementById("sha256Value");
const sha512ValueElement = document.getElementById("sha512Value");
const sha256ComputeButtonElement = document.getElementById("sha256ComputeButton");
const sha512ComputeButtonElement = document.getElementById("sha512ComputeButton");
const sha256CopyButtonElement = document.getElementById("sha256CopyButton");
const sha512CopyButtonElement = document.getElementById("sha512CopyButton");

let currentFile = null;
let currentSourceDescription = "";
let currentAnalysisTimestampUtc = "";

/* UI helpers */
function setStatusMessage(message) { statusMessageElement.textContent = message; }
function clearStatusMessage() { statusMessageElement.textContent = ""; }
function getCurrentTimestampUtc() { return new Date().toISOString(); }

function formatBytes(bytes) {
  const kilo = 1024;
  if (bytes < kilo) return bytes + " B";
  const units = ["KB", "MB", "GB", "TB", "PB"];
  let value = bytes;
  let unitIndex = -1;
  do { value /= kilo; unitIndex += 1; } while (value >= kilo && unitIndex < units.length - 1);
  const roundedValue = value >= 100 ? Math.round(value) : Math.round(value * 10) / 10;
  return roundedValue + " " + units[unitIndex];
}
function toHex(n, width) { const s = (Number(n) >>> 0).toString(16); return "0x" + s.padStart(width || 0, "0"); }
function hexDec(n, width) { return Number.isFinite(n) ? (n + " (" + toHex(n, width) + ")") : String(n); }
function hexOnly(n, width) { return toHex(n, width); } // keep where hex is the canonical view (RVA/VA etc.)
function readAscii(view, offset, length) {
  if (offset + length > view.byteLength) return "";
  let s = "";
  for (let i = 0; i < length; i += 1) s += String.fromCharCode(view.getUint8(offset + i));
  return s;
}

/* file reads */
async function readRange(file, start, length) { return await file.slice(start, start + length).arrayBuffer(); }
async function readHead(file, length) { const n = Math.min(file.size, length); return await readRange(file, 0, n); }

/* ELF head (brief) */
function detectElfHead(view) {
  if (view.byteLength < 0x14) return null;
  if (view.getUint8(0)!==0x7f || view.getUint8(1)!==0x45 || view.getUint8(2)!==0x4c || view.getUint8(3)!==0x46) return null;
  const cls = view.getUint8(4), data = view.getUint8(5), le = data === 1;
  const eType = view.getUint16(0x10, le), eMachine = view.getUint16(0x12, le);
  const bitness = cls===1?"32-bit":cls===2?"64-bit":"unknown-width";
  const endian = data===1?"LSB":data===2?"MSB":"unknown-endian";
  const mach = eMachine===0x03?"x86":eMachine===0x3e?"x86-64":eMachine===0x28?"ARM":eMachine===0xb7?"ARM64":eMachine===0x08?"MIPS":"machine=0x"+eMachine.toString(16);
  const kind = eType===1?"relocatable":eType===2?"executable":eType===3?"shared object":eType===4?"core":"type=0x"+eType.toString(16);
  return "ELF " + bitness + " " + endian + " " + kind + ", " + mach;
}

/* PE helpers: enums/flags */
const MACHINE_KNOWN = [
  [0x014c,"x86"], [0x8664,"x86-64"], [0x01c0,"ARM"], [0xaa64,"ARM64"], [0x0200,"IA64"],
  [0x0166,"MIPS"], [0x01f0,"POWERPC"], [0x5032,"RISC-V32"], [0x5064,"RISC-V64"], [0x01c4,"ARM Thumb-2"]
];
const SUBSYSTEMS = [
  [0,"Unknown"], [1,"Native"], [2,"GUI"], [3,"Console"], [5,"OS/2 CUI"], [7,"POSIX CUI"], [9,"Windows CE GUI"],
  [10,"EFI Application"], [11,"EFI Boot Service Driver"], [12,"EFI Runtime Driver"], [13,"EFI ROM"], [14,"Xbox"], [16,"Boot Application"]
];
const CHAR_FLAGS = [
  [0x0001,"RELOCS_STRIPPED","Relocations have been stripped."],
  [0x0002,"EXECUTABLE_IMAGE","Image is executable."],
  [0x0004,"LINE_NUMS_STRIPPED","COFF line numbers stripped (deprecated)."],
  [0x0008,"LOCAL_SYMS_STRIPPED","Local symbols stripped (deprecated)."],
  [0x0010,"AGGRESSIVE_WS_TRIM","Aggressive WS trim (obsolete)."],
  [0x0020,"LARGE_ADDRESS_AWARE","Can handle >2GB addresses."],
  [0x0080,"BYTES_REVERSED_LO","Little-endian (obsolete use)."],
  [0x0100,"32BIT_MACHINE","Machine is 32-bit."],
  [0x0200,"DEBUG_STRIPPED","Debug info stripped."],
  [0x0400,"REMOVABLE_RUN_FROM_SWAP","Copy to swap if on removable media."],
  [0x0800,"NET_RUN_FROM_SWAP","Copy to swap if on network media."],
  [0x1000,"SYSTEM","System file."],
  [0x2000,"DLL","Dynamic-link library."],
  [0x4000,"UP_SYSTEM_ONLY","Uniprocessor only."],
  [0x8000,"BYTES_REVERSED_HI","Big-endian (obsolete use)."]
];
const DLL_CHAR_FLAGS = [
  [0x0020,"HIGH_ENTROPY_VA","High-entropy ASLR (PE32+)."],
  [0x0040,"DYNAMIC_BASE","Relocatable (ASLR)."],
  [0x0080,"FORCE_INTEGRITY","Code integrity checks."],
  [0x0100,"NX_COMPAT","DEP compatible."],
  [0x0200,"NO_ISOLATION","No isolation."],
  [0x0400,"NO_SEH","No SEH."],
  [0x0800,"NO_BIND","Do not bind imports."],
  [0x1000,"APPCONTAINER","AppContainer aware."],
  [0x2000,"WDM_DRIVER","WDM driver."],
  [0x4000,"GUARD_CF","Control Flow Guard."],
  [0x8000,"TERMINAL_SERVER_AWARE","Terminal Server aware."]
];

function peProbe(view) {
  if (view.byteLength < 0x40) return null;
  if (view.getUint8(0)!==0x4d || view.getUint8(1)!==0x5a) return null;
  if (view.byteLength < 0x3c + 4) return { mz: true, e_lfanew: null };
  return { mz: true, e_lfanew: view.getUint32(0x3c, true) };
}

/* DOS stub analysis */
function isPrintableAscii(code) { return code >= 0x20 && code <= 0x7e; }
function extractDollarStrings(bytes, minLen) {
  const out = [];
  for (let i = 0; i < bytes.length; i += 1) {
    if (bytes[i] === 0x24) { // '$'
      let j = i - 1, run = "";
      while (j >= 0 && isPrintableAscii(bytes[j])) { run = String.fromCharCode(bytes[j]) + run; j -= 1; if (run.length > 512) break; }
      if (run.length >= minLen) out.push(run);
    }
  }
  return out;
}
function extractPlainAsciiRuns(bytes, minLen) {
  const out = [];
  let run = "";
  for (let i = 0; i < bytes.length; i += 1) {
    const b = bytes[i];
    if (isPrintableAscii(b)) {
      run += String.fromCharCode(b);
      if (run.length > 2048) { out.push(run); run = ""; }
    } else {
      if (run.length >= minLen) out.push(run);
      run = "";
    }
  }
  if (run.length >= minLen) out.push(run);
  return out;
}
function containsInt21(bytes) {
  for (let i = 0; i + 1 < bytes.length; i += 1) if (bytes[i]===0xcd && bytes[i+1]===0x21) return true;
  return false;
}

/* PE parse (streamed slices, rich details) */
async function parsePeDetails(file) {
  const head = await readHead(file, 0x40);
  const dv = new DataView(head);
  const probe = peProbe(dv);
  if (!probe) return null;

  const details = { dos:{}, peSignature:null, coff:{}, optional:{}, dataDirectories:[], sections:[] };

  details.dos.e_magic = readAscii(dv, 0, 2);
  details.dos.e_lfanew = probe.e_lfanew == null ? null : probe.e_lfanew;

  // DOS stub region: from 0x40 to e_lfanew (if sane)
  if (probe.e_lfanew != null && probe.e_lfanew > 0x40 && probe.e_lfanew <= file.size) {
    const len = Math.min(probe.e_lfanew - 0x40, 64 * 1024);
    const buf = await readRange(file, 0x40, len);
    const bytes = new Uint8Array(buf);
    const hasInt = containsInt21(bytes);
    const dollarText = extractDollarStrings(bytes, 6);
    const asciiRuns = extractPlainAsciiRuns(bytes, 12);
    const classic = asciiRuns.find(s => /this program cannot be run in dos mode/i.test(s));
    if (classic) {
      details.dos.stub = { kind: "standard", note: "classic DOS message", strings: [classic] };
    } else if (hasInt && dollarText.length) {
      details.dos.stub = { kind: "standard", note: "INT 21h + $-terminated", strings: dollarText.slice(0, 4) };
    } else if (asciiRuns.length) {
      details.dos.stub = { kind: "non-standard", note: "printable text without classic pattern", strings: asciiRuns.slice(0, 4) };
    } else {
      details.dos.stub = { kind: "none", note: "no printable text", strings: [] };
    }
  } else {
    details.dos.stub = { kind: "none", note: "no stub region", strings: [] };
  }

  if (probe.e_lfanew == null || probe.e_lfanew + 24 > file.size) return details;

  // PE signature + COFF
  const coffBuf = await readRange(file, probe.e_lfanew, 24);
  const c = new DataView(coffBuf);
  details.peSignature = readAscii(c, 0, 2) + String.fromCharCode(c.getUint8(2)) + String.fromCharCode(c.getUint8(3));

  const coffOff = 4;
  const machine = c.getUint16(coffOff + 0, true);
  const numberOfSections = c.getUint16(coffOff + 2, true);
  const timeDateStamp = c.getUint32(coffOff + 4, true);
  const ptrToSymTable = c.getUint32(coffOff + 8, true);
  const numberOfSymbols = c.getUint32(coffOff + 12, true);
  const sizeOfOptionalHeader = c.getUint16(coffOff + 16, true);
  const characteristics = c.getUint16(coffOff + 18, true);

  details.coff = {
    Machine: machine,
    MachineText: MACHINE_KNOWN.find(([code])=>code===machine)?.[1] || ("machine=" + toHex(machine,4)),
    NumberOfSections: numberOfSections,
    TimeDateStamp: new Date(timeDateStamp * 1000).toISOString(),
    TimeDateStampRaw: toHex(timeDateStamp,8),
    PointerToSymbolTable: ptrToSymTable,
    NumberOfSymbols: numberOfSymbols,
    SizeOfOptionalHeader: sizeOfOptionalHeader,
    Characteristics: characteristics
  };

  // Optional header
  const optOffset = probe.e_lfanew + 24;
  const optBuf = await readRange(file, optOffset, Math.min(sizeOfOptionalHeader, 0x300));
  const o = new DataView(optBuf);
  if (o.byteLength < 2) return details;

  let p = 0;
  const magic = o.getUint16(p, true); p += 2;
  const majorLinker = o.getUint8(p); p += 1;
  const minorLinker = o.getUint8(p); p += 1;
  const sizeOfCode = o.getUint32(p, true); p += 4;
  const sizeOfInitData = o.getUint32(p, true); p += 4;
  const sizeOfUninitData = o.getUint32(p, true); p += 4;
  const entryRva = o.getUint32(p, true); p += 4;
  const baseOfCode = o.getUint32(p, true); p += 4;
  let baseOfData = null;

  const isPe32 = magic === 0x10b;
  const isPe32Plus = magic === 0x20b;
  if (isPe32) { baseOfData = o.getUint32(p, true); p += 4; }

  let imageBase;
  if (isPe32Plus) { imageBase = Number(o.getBigUint64(p, true)); p += 8; } else { imageBase = o.getUint32(p, true); p += 4; }

  const sectionAlignment = o.getUint32(p, true); p += 4;
  const fileAlignment = o.getUint32(p, true); p += 4;
  const majorOS = o.getUint16(p, true); p += 2;
  const minorOS = o.getUint16(p, true); p += 2;
  const majorImg = o.getUint16(p, true); p += 2;
  const minorImg = o.getUint16(p, true); p += 2;
  const majorSub = o.getUint16(p, true); p += 2;
  const minorSub = o.getUint16(p, true); p += 2;
  const win32VersionValue = o.getUint32(p, true); p += 4;
  const sizeOfImage = o.getUint32(p, true); p += 4;
  const sizeOfHeaders = o.getUint32(p, true); p += 4;
  const checkSum = o.getUint32(p, true); const checkSumRel = p; p += 4;
  const subsystem = o.getUint16(p, true); p += 2;
  const dllChars = o.getUint16(p, true); p += 2;

  const sizeOfStackReserve = isPe32Plus ? Number(o.getBigUint64(p, true)) : o.getUint32(p, true); p += isPe32Plus ? 8 : 4;
  const sizeOfStackCommit = isPe32Plus ? Number(o.getBigUint64(p, true)) : o.getUint32(p, true); p += isPe32Plus ? 8 : 4;
  const sizeOfHeapReserve = isPe32Plus ? Number(o.getBigUint64(p, true)) : o.getUint32(p, true); p += isPe32Plus ? 8 : 4;
  const sizeOfHeapCommit = isPe32Plus ? Number(o.getBigUint64(p, true)) : o.getUint32(p, true); p += isPe32Plus ? 8 : 4;
  const loaderFlags = o.getUint32(p, true); p += 4;
  const numberOfRvaAndSizes = o.getUint32(p, true); p += 4;

  details.optional = {
    Magic: magic,
    MagicText: isPe32 ? "PE32" : isPe32Plus ? "PE32+" : (magic===0x107?"PE32 (ROM image)":"Unknown"),
    LinkerVersion: majorLinker + "." + minorLinker,
    SizeOfCode: sizeOfCode,
    SizeOfInitializedData: sizeOfInitData,
    SizeOfUninitializedData: sizeOfUninitData,
    AddressOfEntryPoint: entryRva,
    BaseOfCode: baseOfCode,
    BaseOfData: isPe32 ? baseOfData : undefined,
    ImageBase: imageBase,
    SectionAlignment: sectionAlignment,
    FileAlignment: fileAlignment,
    OSVersion: majorOS + "." + minorOS,
    ImageVersion: majorImg + "." + minorImg,
    SubsystemVersion: majorSub + "." + minorSub,
    Win32VersionValue: win32VersionValue,
    SizeOfImage: sizeOfImage,
    SizeOfHeaders: sizeOfHeaders,
    CheckSum: checkSum,
    Subsystem: subsystem,
    DllCharacteristics: dllChars,
    SizeOfStackReserve: sizeOfStackReserve,
    SizeOfStackCommit: sizeOfStackCommit,
    SizeOfHeapReserve: sizeOfHeapReserve,
    SizeOfHeapCommit: sizeOfHeapCommit,
    LoaderFlags: loaderFlags,
    NumberOfRvaAndSizes: numberOfRvaAndSizes,
    _offsets: { optionalHeaderFileOffset: optOffset, checkSumFileOffset: optOffset + checkSumRel }
  };

  // Data directories (max 16 standard)
  const names = ["EXPORT","IMPORT","RESOURCE","EXCEPTION","SECURITY","BASERELOC","DEBUG","ARCHITECTURE","GLOBALPTR","TLS","LOAD_CONFIG","BOUND_IMPORT","IAT","DELAY_IMPORT","CLR_RUNTIME","RESERVED"];
  const ddCount = Math.min(numberOfRvaAndSizes, Math.floor((o.byteLength - p) / 8), 16);
  for (let i = 0; i < ddCount; i += 1) {
    const rva = o.getUint32(p + i*8 + 0, true);
    const sz  = o.getUint32(p + i*8 + 4, true);
    details.dataDirectories.push({ index:i, name:names[i] || "", rva, size:sz });
  }

  // Section headers (each 40 bytes)
  const sectTableOffset = optOffset + sizeOfOptionalHeader;
  if (numberOfSections > 0 && sectTableOffset + numberOfSections * 40 <= file.size) {
    const sectBuf = await readRange(file, sectTableOffset, numberOfSections * 40);
    const sv = new DataView(sectBuf);
    for (let i = 0; i < numberOfSections; i += 1) {
      const b = i * 40;
      let name = "";
      for (let j = 0; j < 8; j += 1) { const ch = sv.getUint8(b + j); if (ch===0) break; name += String.fromCharCode(ch); }
      const virtualSize      = sv.getUint32(b + 8,  true);
      const virtualAddress   = sv.getUint32(b + 12, true);
      const sizeOfRawData    = sv.getUint32(b + 16, true);
      const pointerToRawData = sv.getUint32(b + 20, true);
      const characteristics  = sv.getUint32(b + 36, true);
      details.sections.push({ name: name || "(unnamed)", virtualSize, virtualAddress, sizeOfRawData, pointerToRawData, characteristics });
    }
  }

  return details;
}

/* Render helpers for “known options” rows */
function renderKnownOptionsRow(selectedCode, options) {
  const spans = options.map(([code,label]) => {
    const cls = "opt " + (code===selectedCode ? "sel" : "dim");
    return "<span class=\"" + cls + "\" title=\"" + label + " (" + toHex(code,4) + ")\">" + label + "</span>";
  }).join("");
  return "<div class=\"optionsRow\">" + spans + "</div>";
}
function renderFlagsList(mask, flags) {
  return "<div class=\"optionsRow\">" + flags.map(([bit, name, tip]) => {
    const on = (mask & bit) !== 0;
    const cls = "opt " + (on ? "sel" : "dim");
    const title = (tip ? name + " — " + tip : name) + " (" + toHex(bit,4) + ")";
    return "<span class=\"" + cls + "\" title=\"" + title + "\">" + name + "</span>";
  }).join("") + "</div>";
}

function ddRow(k, v, title) {
  const t = title ? " title=\"" + String(title).replace(/"/g,"&quot;") + "\"" : "";
  return "<dt" + t + ">" + k + "</dt><dd>" + v + "</dd>";
}

/* Data directory tooltips (what is it) */
const DD_TIPS = {
  EXPORT: "Export table (functions this image exports).",
  IMPORT: "Import table (functions this image imports).",
  RESOURCE: "Resources (icons, dialogs, strings).",
  EXCEPTION: "Exception handling data (.pdata on x64).",
  SECURITY: "WIN_CERTIFICATE / Authenticode.",
  BASERELOC: "Relocation info (.reloc).",
  DEBUG: "Debug directory (CodeView/PDB info, etc.).",
  ARCHITECTURE: "Reserved/unused in PE.",
  GLOBALPTR: "Global pointer (obsolete).",
  TLS: "Thread Local Storage.",
  LOAD_CONFIG: "Load config (CFG, SEH, etc.).",
  BOUND_IMPORT: "Bound import info (pre-bound addresses).",
  IAT: "Import Address Table (thunks).",
  DELAY_IMPORT: "Delay-load import table.",
  CLR_RUNTIME: ".NET (CLR) header.",
  RESERVED: "Reserved."
};

/* Section name quick hints (conventional, not mandatory) */
function sectionHint(name) {
  const n = name.toLowerCase();
  if (n === ".text") return "Code";
  if (n === ".data") return "Initialized data";
  if (n === ".rdata") return "Read-only data";
  if (n === ".rsrc") return "Resources";
  if (n === ".reloc") return "Base relocations";
  if (n === ".bss") return "Uninitialized data";
  if (n.startsWith(".tls")) return "Thread local storage";
  return "User-defined section name";
}

/* Render PE details → HTML */
function renderPeDetails(details) {
  if (!details) return "";

  const out = [];

  // DOS header & stub
  const eMagicTitle = "DOS signature (2 bytes). Must be 'MZ'.";
  const eLfaTitle = "File offset (32-bit) to the PE signature. Range: 0..4,294,967,295.";
  out.push("<section><h4 style=\"margin:0 0 0.5rem 0;font-size:0.9rem\">DOS header</h4>");
  out.push("<dl>");
  out.push(ddRow("e_magic", details.dos.e_magic, eMagicTitle));
  out.push(ddRow("e_lfanew", hexDec(details.dos.e_lfanew ?? 0,8), eLfaTitle));
  out.push("</dl>");
  const stub = details.dos.stub;
  const stubLine = (stub && stub.kind) ? ("DOS stub: " + stub.kind + (stub.note ? " — " + stub.note : "")) : "DOS stub";
  const lines = (stub && Array.isArray(stub.strings) && stub.strings.length)
    ? "<div class=\"mono smallNote\">" + stub.strings.map(s => "<div>"+String(s).replace(/</g,"&lt;")+"</div>").join("") + "</div>"
    : "<div class=\"smallNote\">No printable stub text</div>";
  out.push("<div class=\"smallNote\">" + stubLine + "</div>" + lines + "</section>");

  // PE signature
  out.push("<section><h4 style=\"margin:0 0 0.5rem 0;font-size:0.9rem\">PE signature</h4>");
  out.push("<dl>" + ddRow("Signature", details.peSignature, "PE\\0\\0") + "</dl></section>");

  // COFF header
  out.push("<section><h4 style=\"margin:0 0 0.5rem 0;font-size:0.9rem\">COFF header</h4>");
  const numSecTitle = "16-bit field. Theoretical range 0..65535; practical images usually < 100.";
  const tdsTitle = "UNIX epoch seconds when linked.";
  const ptrSymTitle = "COFF symbol table pointer. For PE this is typically 0 (separate PDB is used).";
  const numSymTitle = "COFF symbols count. Typically 0 for PE with external PDB.";
  const sizeOptTitle = "Size of Optional header in bytes.";
  const charTitle = "Image characteristics bitmask. See flags below.";
  out.push("<dl>");
  out.push(ddRow("Machine", details.coff.MachineText + " (" + toHex(details.coff.Machine,4) + ")", "Target CPU architecture."));
  out.push(ddRow("NumberOfSections", details.coff.NumberOfSections + " (0..65535)", numSecTitle));
  out.push(ddRow("TimeDateStamp", details.coff.TimeDateStamp, tdsTitle + " Raw: " + details.coff.TimeDateStampRaw));
  out.push(ddRow("PointerToSymbolTable", hexDec(details.coff.PointerToSymbolTable,8), ptrSymTitle));
  out.push(ddRow("NumberOfSymbols", details.coff.NumberOfSymbols + " (0..4294967295)", numSymTitle));
  out.push(ddRow("SizeOfOptionalHeader", details.coff.SizeOfOptionalHeader + " bytes", sizeOptTitle));
  out.push(ddRow("Characteristics", toHex(details.coff.Characteristics,4), charTitle));
  out.push("</dl>");
  out.push(renderKnownOptionsRow(details.coff.Machine, MACHINE_KNOWN));
  out.push(renderFlagsList(details.coff.Characteristics, CHAR_FLAGS));
  out.push("</section>");

  // Optional header
  out.push("<section><h4 style=\"margin:0 0 0.5rem 0;font-size:0.9rem\">Optional header</h4>");
  const oh = details.optional;
  const magicTitle = "Format discriminator: PE32 (0x010b), PE32+ (0x020b), or ROM (0x0107).";
  const linkTitle = "Linker version that produced this image.";
  const addrTitle = "RVA (Relative Virtual Address) from image base.";
  const imgBaseTitle = "Preferred image base in memory.";
  const verTitle = "Major.Minor.";
  const zeroMustTitle = "Reserved by spec; must be 0.";
  const checkTitle = "PE checksum (drivers/system files rely on it).";
  const subsTitle = "Execution environment required by the image.";
  const dllcTitle = "DLL characteristics bitmask. See flags below.";
  const alignTitle = "Alignment constraints for sections and raw data.";
  const rvaNumTitle = "Number of directory entries; standard PE uses up to 16.";
  out.push("<dl>");
  out.push(ddRow("Magic", oh.MagicText + " (" + toHex(oh.Magic,4) + ")", magicTitle));
  out.push(ddRow("LinkerVersion", oh.LinkerVersion, linkTitle));
  out.push(ddRow("SizeOfCode", hexDec(oh.SizeOfCode,8), "Size in bytes of code (.text)."));
  out.push(ddRow("SizeOfInitializedData", hexDec(oh.SizeOfInitializedData,8), "Size in bytes of initialized data."));
  out.push(ddRow("SizeOfUninitializedData", hexDec(oh.SizeOfUninitializedData,8), "Size in bytes of uninitialized data (BSS)."));
  out.push(ddRow("AddressOfEntryPoint", hexOnly(oh.AddressOfEntryPoint,8), addrTitle));
  out.push(ddRow("BaseOfCode", hexOnly(oh.BaseOfCode,8), addrTitle));
  if (oh.BaseOfData !== undefined) out.push(ddRow("BaseOfData", hexOnly(oh.BaseOfData,8), addrTitle));
  out.push(ddRow("ImageBase", isFinite(oh.ImageBase) ? (oh.ImageBase + " (" + toHex(oh.ImageBase, oh.MagicText==="PE32+"?16:8) + ")") : String(oh.ImageBase), imgBaseTitle));
  out.push(ddRow("SectionAlignment", hexDec(oh.SectionAlignment,8), alignTitle));
  out.push(ddRow("FileAlignment", hexDec(oh.FileAlignment,8), alignTitle));
  out.push(ddRow("OSVersion", oh.OSVersion, verTitle));
  out.push(ddRow("ImageVersion", oh.ImageVersion, verTitle));
  out.push(ddRow("SubsystemVersion", oh.SubsystemVersion, verTitle));
  out.push(ddRow("Win32VersionValue", hexDec(oh.Win32VersionValue,8), zeroMustTitle));
  out.push(ddRow("SizeOfImage", hexDec(oh.SizeOfImage,8), "Size of image in memory (aligned)."));
  out.push(ddRow("SizeOfHeaders", hexDec(oh.SizeOfHeaders,8), "Combined size of all headers."));
  out.push(ddRow("CheckSum", hexDec(oh.CheckSum,8), checkTitle));
  const _sub = SUBSYSTEMS.find(([code]) => code === oh.Subsystem);
  const _subText = (_sub ? _sub[1] : ("subsystem=" + oh.Subsystem)) + " (" + toHex(oh.Subsystem, 4) + ")";
  out.push(ddRow("Subsystem", _subText, subsTitle));
  out.push(ddRow("DllCharacteristics", toHex(oh.DllCharacteristics,4), dllcTitle));
  out.push(ddRow("SizeOfStackReserve", hexDec(oh.SizeOfStackReserve, oh.MagicText==="PE32+"?16:8), "Initial stack reserve size."));
  out.push(ddRow("SizeOfStackCommit", hexDec(oh.SizeOfStackCommit, oh.MagicText==="PE32+"?16:8), "Initial stack commit size."));
  out.push(ddRow("SizeOfHeapReserve", hexDec(oh.SizeOfHeapReserve, oh.MagicText==="PE32+"?16:8), "Initial heap reserve size."));
  out.push(ddRow("SizeOfHeapCommit", hexDec(oh.SizeOfHeapCommit, oh.MagicText==="PE32+"?16:8), "Initial heap commit size."));
  out.push(ddRow("LoaderFlags", hexDec(oh.LoaderFlags,8), "Reserved; must be 0."));
  out.push(ddRow("NumberOfRvaAndSizes", oh.NumberOfRvaAndSizes + " (0..16)", rvaNumTitle));
  out.push("</dl>");
  out.push(renderKnownOptionsRow(oh.Magic, [[0x010b,"PE32"],[0x020b,"PE32+"],[0x0107,"ROM"]]));
  out.push(renderKnownOptionsRow(oh.Subsystem, SUBSYSTEMS));
  out.push(renderFlagsList(oh.DllCharacteristics, DLL_CHAR_FLAGS));
  out.push("</section>");

  // Data directories
  if (details.dataDirectories.length > 0) {
    out.push("<section><h4 style=\"margin:0 0 0.5rem 0;font-size:0.9rem\">Data directories</h4><dl>");
    for (const d of details.dataDirectories) {
      const tip = DD_TIPS[d.name] || "Directory";
      out.push(ddRow("[" + d.index + "] " + d.name, "RVA " + hexOnly(d.rva,8) + ", Size " + hexDec(d.size,8), tip));
    }
    out.push("</dl></section>");
  }

  // Sections
  if (details.sections.length > 0) {
    out.push("<section><h4 style=\"margin:0 0 0.5rem 0;font-size:0.9rem\">Section headers</h4><dl>");
    for (const s of details.sections) {
      const line = "VS " + hexOnly(s.virtualSize,8) +
                   ", VA " + hexOnly(s.virtualAddress,8) +
                   ", RawSize " + hexDec(s.sizeOfRawData,8) +
                   ", RawPtr " + hexDec(s.pointerToRawData,8) +
                   ", Chars " + hexOnly(s.characteristics,8);
      out.push(ddRow(s.name, line, sectionHint(s.name)));
    }
    out.push("</dl></section>");
  }

  return out.join("");
}

function renderPeIntoUi(details) {
  if (!details) {
    peDetailsTermElement.hidden = true;
    peDetailsValueElement.hidden = true;
    peDetailsValueElement.innerHTML = "";
    return;
  }
  peDetailsTermElement.hidden = false;
  peDetailsValueElement.hidden = false;
  peDetailsValueElement.innerHTML = renderPeDetails(details);
}

/* Quick bin type probes beyond PE */
function detectMachOHead(view) {
  if (view.byteLength < 4) return null;
  const be = view.getUint32(0, false), le = view.getUint32(0, true);
  const M32BE=0xfeedface,M32LE=0xcefaedfe,M64BE=0xfeedfacf,M64LE=0xcffaedfe,FATBE=0xcafebabe,FATLE=0xbebafeca;
  if (be===M32BE) return "Mach-O 32-bit big-endian";
  if (le===M32LE) return "Mach-O 32-bit little-endian";
  if (be===M64BE) return "Mach-O 64-bit big-endian";
  if (le===M64LE) return "Mach-O 64-bit little-endian";
  if (be===FATBE || le===FATLE) return "Mach-O universal binary (Fat)";
  return null;
}
function detectPdfHead(view) {
  if (view.byteLength < 5) return null;
  if (view.getUint8(0)===0x25 && view.getUint8(1)===0x50 && view.getUint8(2)===0x44 && view.getUint8(3)===0x46 && view.getUint8(4)===0x2d) {
    let ascii = ""; for (let i=0;i<Math.min(32,view.byteLength);i++){ const c=view.getUint8(i); if(c===0x0a||c===0x0d)break; if(c>=0x20&&c<=0x7e) ascii+=String.fromCharCode(c); else break; }
    return "PDF document (" + ascii + ")";
  }
  return null;
}
function detectZipHead(view) { if (view.byteLength < 4) return null; if (view.getUint8(0)===0x50&&view.getUint8(1)===0x4b&&view.getUint8(2)===0x03&&view.getUint8(3)===0x04) return "ZIP archive (PK)"; return null; }
function detectGzipHead(view) { if (view.byteLength < 2) return null; if (view.getUint8(0)===0x1f&&view.getUint8(1)===0x8b) return "gzip compressed data"; return null; }
function detectPngHead(view) { if (view.byteLength < 8) return null; if (view.getUint8(0)===0x89&&view.getUint8(1)===0x50&&view.getUint8(2)===0x4e&&view.getUint8(3)===0x47&&view.getUint8(4)===0x0d&&view.getUint8(5)===0x0a&&view.getUint8(6)===0x1a&&view.getUint8(7)===0x0a) return "PNG image"; return null; }
function detectJpegHead(view){ if (view.byteLength < 3) return null; if (view.getUint8(0)===0xff&&view.getUint8(1)===0xd8&&view.getUint8(2)===0xff) return "JPEG image"; return null; }
function detectGifHead(view) { if (view.byteLength < 6) return null; const sig = readAscii(view,0,6); if (sig==="GIF87a"||sig==="GIF89a") return "GIF image ("+sig+")"; return null; }
function detectEbmlHead(view){ if (view.byteLength < 4) return null; if (view.getUint8(0)===0x1a&&view.getUint8(1)===0x45&&view.getUint8(2)===0xdf&&view.getUint8(3)===0xa3) return "EBML container (Matroska/WebM family)"; return null; }
function detectRarHead(view) {
  if (view.byteLength < 8) return null;
  if (view.getUint8(0)===0x52&&view.getUint8(1)===0x61&&view.getUint8(2)===0x72&&view.getUint8(3)===0x21&&view.getUint8(4)===0x1a&&view.getUint8(5)===0x07&&view.getUint8(6)===0x00) return "RAR archive (v4)";
  if (view.getUint8(0)===0x52&&view.getUint8(1)===0x61&&view.getUint8(2)===0x72&&view.getUint8(3)===0x21&&view.getUint8(4)===0x1a&&view.getUint8(5)===0x07&&view.getUint8(6)===0x01&&view.getUint8(7)===0x00) return "RAR archive (v5)";
  return null;
}
function detectMpegPsHead(view) {
  const n = Math.min(view.byteLength, 64);
  for (let i = 0; i + 3 < n; i += 1) if (view.getUint8(i)===0x00&&view.getUint8(i+1)===0x00&&view.getUint8(i+2)===0x01&&view.getUint8(i+3)===0xba) return "MPEG Program Stream";
  return null;
}
async function detectIso9660(file) { if (file.size < 0x8001 + 5) return null; const buf = await readRange(file, 0x8001, 5); const v = new DataView(buf); if (readAscii(v,0,5)==="CD001") return "ISO 9660 filesystem image"; return null; }
async function detectTga(file) { if (file.size < 26) return null; const buf = await readRange(file, file.size - 26, 26); const v = new DataView(buf); if (readAscii(v,8,18)==="TRUEVISION-XFILE") return "TGA image"; return null; }

async function detectBinaryTypeAsync(file) {
  const headBuf = await readHead(file, 64);
  const h = new DataView(headBuf);
  const headDetectors = [detectElfHead,detectMachOHead,detectPdfHead,detectZipHead,detectGzipHead,detectPngHead,detectJpegHead,detectGifHead,detectEbmlHead,detectRarHead,detectMpegPsHead];
  for (const detector of headDetectors) { const r = detector(h); if (r) return r; }
  const peCandidate = peProbe(h);
  if (peCandidate) {
    const details = await parsePeDetails(file);
    if (details) {
      // Produce compact summary from details:
      const sig = (details.optional?.MagicText) || "PE";
      const isDll = (details.coff && (details.coff.Characteristics & 0x2000) !== 0);
      const mach = details.coff?.MachineText || "unknown";
      // e.g., "PE32+ executable for x86-64"
      return sig + " " + (isDll ? "DLL" : "executable") + " for " + mach;
    }
  }
  const iso = await detectIso9660(file); if (iso) return iso;
  const tga = await detectTga(file); if (tga) return tga;
  return "Unknown binary type";
}

/* Show file info + PE details */
async function showFileInformation(file, sourceDescription, analysisTimestampUtc) {
  currentFile = file;
  currentSourceDescription = sourceDescription;
  currentAnalysisTimestampUtc = analysisTimestampUtc;

  try {
    const binaryType = await detectBinaryTypeAsync(file);
    const readableSize = formatBytes(file.size);

    fileOriginalNameElement.textContent = file.name || "";
    fileSizeDisplayElement.textContent = readableSize;
    fileKindDisplayElement.textContent = binaryType;

    fileNameDetailElement.textContent = file.name || "";
    fileSizeDetailElement.textContent = readableSize + " (" + file.size + " bytes)";
    fileTimestampDetailElement.textContent = analysisTimestampUtc;
    fileSourceDetailElement.textContent = sourceDescription;
    fileBinaryTypeDetailElement.textContent = binaryType;

    if (binaryType.startsWith("PE")) {
      const details = await parsePeDetails(file);
      renderPeIntoUi(details);
    } else {
      renderPeIntoUi(null);
    }

    sha256ValueElement.textContent = "";
    sha512ValueElement.textContent = "";
    sha256CopyButtonElement.hidden = true;
    sha512CopyButtonElement.hidden = true;
    sha256ComputeButtonElement.hidden = false;
    sha512ComputeButtonElement.hidden = false;
    sha256ComputeButtonElement.disabled = false;
    sha512ComputeButtonElement.disabled = false;
    sha256ComputeButtonElement.textContent = "Compute SHA-256";
    sha512ComputeButtonElement.textContent = "Compute SHA-512";

    fileInfoCardElement.hidden = false;
    clearStatusMessage();
  } catch (error) {
    const readableSize = formatBytes(file.size);

    fileOriginalNameElement.textContent = file.name || "";
    fileSizeDisplayElement.textContent = readableSize;
    fileKindDisplayElement.textContent = "Unreadable";

    fileNameDetailElement.textContent = file.name || "";
    fileSizeDetailElement.textContent = readableSize + " (" + file.size + " bytes)";
    fileTimestampDetailElement.textContent = analysisTimestampUtc;
    fileSourceDetailElement.textContent = sourceDescription;
    fileBinaryTypeDetailElement.textContent = "Could not detect binary type: " + String(error);

    renderPeIntoUi(null);

    sha256ValueElement.textContent = "";
    sha512ValueElement.textContent = "";
    sha256CopyButtonElement.hidden = true;
    sha512CopyButtonElement.hidden = true;
    sha256ComputeButtonElement.hidden = false;
    sha512ComputeButtonElement.hidden = false;
    sha256ComputeButtonElement.disabled = false;
    sha512ComputeButtonElement.disabled = false;
    sha256ComputeButtonElement.textContent = "Compute SHA-256";
    sha512ComputeButtonElement.textContent = "Compute SHA-512";

    fileInfoCardElement.hidden = false;
    clearStatusMessage();
  }
}

/* Input glue */
function createFileFromString(content, suggestedType) { return new File([content], "", { type: suggestedType || "application/octet-stream" }); }
function handleIncomingFileList(fileList, sourceDescription) {
  if (!fileList || fileList.length === 0) { setStatusMessage(sourceDescription + ": no files or unsupported item (for example, a directory)."); return; }
  if (fileList.length > 1) { setStatusMessage(sourceDescription + ": multiple files are not supported yet."); return; }
  const firstFile = fileList[0];
  const timestampUtc = getCurrentTimestampUtc();
  showFileInformation(firstFile, sourceDescription, timestampUtc);
}

["dragenter","dragover"].forEach(t => dropZoneElement.addEventListener(t, e => { e.preventDefault(); dropZoneElement.classList.add("dragover"); }));
["dragleave","drop"].forEach(t => dropZoneElement.addEventListener(t, e => {
  e.preventDefault();
  if (e.type === "drop") {
    const dt = e.dataTransfer;
    if (!dt) setStatusMessage("Drop: could not access data."); else handleIncomingFileList(dt.files, "Drop");
  }
  dropZoneElement.classList.remove("dragover");
}));
dropZoneElement.addEventListener("keydown", e => { if (e.key===" "||e.key==="Enter") { e.preventDefault(); fileInputElement.click(); } });
fileInputElement.addEventListener("change", e => {
  const target = e.currentTarget;
  if (!(target instanceof HTMLInputElement)) return;
  handleIncomingFileList(target.files, "File selection");
  target.value = "";
});

window.addEventListener("paste", async e => {
  const data = e.clipboardData;
  if (!data) { setStatusMessage("Paste: clipboard not available."); return; }
  const files=[], strings=[];
  for (const it of data.items) { if (it.kind==="file") { const f=it.getAsFile(); if (f) files.push(f); } else if (it.kind==="string") { strings.push(it); } }
  if (files.length>0 && strings.length>0) { setStatusMessage("Paste: clipboard has multiple data items (file and text); not supported yet."); return; }
  if (files.length>0) { if (files.length===1) handleIncomingFileList(files, "Paste (file)"); else setStatusMessage("Paste: multiple files are not supported yet."); return; }
  if (strings.length===0) { setStatusMessage("Paste: no usable clipboard data."); return; }
  if (strings.length>1) { setStatusMessage("Paste: multiple clipboard text items are not supported yet."); return; }
  const strItem = strings[0];
  const textContent = await new Promise(resolve => { strItem.getAsString(s => resolve(s)); });
  if (typeof textContent !== "string" || textContent.length === 0) { setStatusMessage("Paste: clipboard text item is empty."); return; }
  handleIncomingFileList([createFileFromString(textContent, strItem.type || "application/octet-stream")], "Paste (clipboard data)");
});

/* Hashing */
function arrayBufferToHex(arrayBuffer) { const bytes = new Uint8Array(arrayBuffer); let hex = ""; for (const b of bytes) hex += b.toString(16).padStart(2,"0"); return hex; }
async function copyToClipboard(text) { try { await navigator.clipboard.writeText(text); return true; } catch { return false; } }
async function computeHash(algorithm, file, valueElement, computeButtonElement, copyButtonElement) {
  if (!file) { valueElement.textContent = "No file selected."; return; }
  computeButtonElement.disabled = true; computeButtonElement.textContent = "Working…";
  try {
    const fullBuffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest(algorithm, fullBuffer);
    const hexValue = arrayBufferToHex(hashBuffer);
    valueElement.textContent = hexValue;
    copyButtonElement.hidden = false;
    computeButtonElement.hidden = true;
  } catch (error) {
    valueElement.textContent = "Hash failed: " + (error && error.name ? error.name + ": " : "") + String(error);
    computeButtonElement.disabled = false; computeButtonElement.textContent = "Retry"; copyButtonElement.hidden = true;
  }
}
sha256ComputeButtonElement.addEventListener("click", () => computeHash("SHA-256", currentFile, sha256ValueElement, sha256ComputeButtonElement, sha256CopyButtonElement));
sha512ComputeButtonElement.addEventListener("click", () => computeHash("SHA-512", currentFile, sha512ValueElement, sha512ComputeButtonElement, sha512CopyButtonElement));
sha256CopyButtonElement.addEventListener("click", async () => setStatusMessage((await copyToClipboard(sha256ValueElement.textContent||"")) ? "SHA-256 copied." : "Clipboard copy failed for SHA-256."));
sha512CopyButtonElement.addEventListener("click", async () => setStatusMessage((await copyToClipboard(sha512ValueElement.textContent||"")) ? "SHA-512 copied." : "Clipboard copy failed for SHA-512."));
</script>
</body>
</html>
